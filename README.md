# DSA_JS

## Overview

This repository contains practice problems and implementations focused on Data Structures and Algorithms (DSA) using JavaScript. It covers both linear and non-linear data structures, various sorting and searching algorithms, and applies design principles to solve real-world problems efficiently.

## Topics Covered

### Linear Data Structures

- **Arrays**: Basic operations, searching, sorting, sliding window techniques, and space-time optimizations.
- **Linked Lists**: Implementation of singly and doubly linked lists, operations like insertion, deletion, reversal, and cycle detection.
- **Stacks**: LIFO structure used for backtracking, expression evaluation, and recursive simulation.
- **Queues**: FIFO structure implemented using arrays and linked lists; variations like circular queues and priority queues.
- **Hash Tables**: Storing and retrieving key-value pairs efficiently, handling collisions, and optimizing lookups.

### Non-linear Data Structures

- **Trees**: Binary Trees, Binary Search Trees (BST), Tree Traversals (Inorder, Preorder, Postorder), and Balanced Trees (AVL, Red-Black Trees).
- **Graphs**: Representations using adjacency list/matrix, graph traversal algorithms, detecting cycles, and finding shortest paths.

### Sorting Algorithms

- **Bubble Sort**: Simple comparison-based sort.
- **Heap Sort**: Efficient sort using binary heap.
- **Merge Sort**: Divide and conquer sorting algorithm with stable performance.
- **Quick Sort** *(optional)*: Efficient average case sorting algorithm (if implemented in practice files).

### Searching Algorithms

- **Linear Search**: Simple brute-force search.
- **Binary Search**: Efficient search in sorted arrays.
- **Breadth-First Search (BFS)**: Level-order traversal in trees and shortest path discovery in graphs.
- **Depth-First Search (DFS)**: Pre-order, in-order, and post-order tree traversals; graph exploration and backtracking problems.

### Applied Design Principles

- **Structured vs Unstructured Data**: Handling different data formats and applying optimal structures.
- **Problem-solving Patterns**: Two-pointer, sliding window, divide and conquer, greedy, dynamic programming, etc.
- **Code Design**: Writing modular, reusable, and readable code using classes, methods, and helper functions.

